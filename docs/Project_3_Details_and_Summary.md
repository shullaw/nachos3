 <div class="no-overflow w-100 content-alignment-container">
                        <div id="post-content-126765" class="post-content-container">
                            <p dir="ltr" style="text-align:left;"></p><p>Before starting project 3, please understand that the user programs get executed in two ways.</p><ul><li>using -x argument --<ul><li>This is the main user program that starts at first</li></ul></li><li>using exception --<ul><li>In exception.cc, SC_EXEC, SC_JOIN are already implemented</li><li>In the main user program that you run using -x argument, you need to call exec() and join() functions to run other user programs through exception</li><li></li></ul></li></ul><p>For Project 3, you would need to make changes to the following files.</p><ul><li><strong>code/threads/main.cc                  // All program start here</strong><ul><li>This is the point of start for any program.</li><li>The argument -x is already implemented, however need some minor changes as explained here.</li></ul></li></ul><p>if (!strcmp(*argv, "-x")) {               // run a user program<br />       ASSERT(argc &gt; 1);              //<strong> Remove the assert and enclose with if else.</strong><br />       StartProcess(*(argv + 1));    // This is your main function to start the user program<br />                                                    // defined in progtest.cc<br />        printf("I'm here");                 // The above function runs the user program and never returns.<br />                                                    // So, no statement below here will execute.<br />        argCount = 2;                      <br />}</p><ul><li><strong>code/userprog/progtest.cc            // Setup first user program that run using -x argument</strong><ul><li><p>void  StartProcess(char *filename)            //This is the only function you need to make changes</p><ul><li>This is the first place you encounter AddrSpace </li><li>This function is also complete, however, you need to add an error mechanism</li><li>Think of the following errors<ul><li>error in filename</li><li>error in setting up addrspace<ul><li>if demand paging then could be a case of not enough space</li><li>other unknown errors</li></ul></li></ul></li></ul></li></ul></li></ul><ul><li><strong>code/userprog/addrspace.cc               //This is the place where you setup address space for any user program</strong><ul><li>you reach here from two places<ul><li>from main user program that runs using -x and handled in progtest.cc</li><li>from user exceptions that occur when the main user program calls Exec() function to run other user programs</li></ul></li><li>Irrespective of how you reach here you need to handle the following things.<ul><li>Remove all ASSERT statement and surround them with if-else and print a proper error message</li><li>After you have calculated the size, handle <strong>task 4 for swap files</strong><ul><li>create file name based on thread id<ul><li>The base code uses threadID for keeping track of thread id but it is set to 1 as default and incremented in SC_EXEC after setting up AddrSpace</li><li>make the following changes so that you can use threadID in AddrSpace properly.<ul><li>Update constructor as <ul><li>AddrSpace::AddrSpace(OpenFile *executable, int thread_id)   //adding one argument </li><li>update declaration in addrspace.h under AddrSpace class<ul><li>AddrSpace(OpenFile *executable, int thread_id);             // Create an address space,</li></ul></li></ul></li><li>Update relevant statement where addrspace constructor is called<ul><li>in progtest.cc<ul><li>space = new AddrSpace(executable, 0);  //passing 0 as argument as this is the location for main thread</li></ul></li><li>in exception.cc  under SC_EXEC exception<ul><li>space = new AddrSpace(executable, threadID);   //passing threadID as argument for any user program that executes using user exception</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><ul><li><ul><li><ul><li><ul><li>Create swapfile<ul><li>It is better to make a new variable to hold the swap file name in AddrSpace class</li><li>fileSystem-&gt;Create(swapFilename, size);     //This will create a file and allocate space</li><li>Open the swap file </li><li>create a buffer (i.e. a temporary array of characters) of size equal to noffH.code.size + noffH.initData.size + noffH.uninitData.size </li><li>copy the data from executable to buffer executable-&gt;ReadAt(your_buffer, size_of_buffer, sizeof(noffH));</li><li>write the buffer to the swapfile using your_sawp_file_pointer-&gt;WriteAt(your_buffer, size_of_buffer, 0);</li><li>delete your pointer to buffer and swap files so that your program does not consume unnecessary memory</li></ul></li></ul></li><li>Handle page table<ul><li>We are not assigning physical page and so the most important and necessary step is to set the <strong>valid bit to false</strong><ul><li>pageTable[i].physicalPage = i; //Comment out this line </li><li>pageTable[i].valid = FALSE;   //This will cause pageFaultException and you need to handle it in exception.cc</li></ul></li><li>No need to find page using bitMap for now.</li><li>We will handle assigning Physical Page during page fault exception</li></ul></li><li></li></ul></li></ul></li></ul><p> </p><ul><li><strong>code/userprog/exception.cc               //This is the place where you setup address space for any user program</strong><ul><li>Here you handle basically two important things<ul><li>Exception due to the user program that you can call<ul><li>SC_EXEC, SC_HALT, SC_JOIN, SC_EXIT are exceptions due to Exec(), Halt(), Join(), and Exit() called in user programs</li><li>So, unless your test programs do not call them you never reach here</li><li>They are already implemented but you need to make a couple of changes as per the current project.</li><li>In SC_EXEC:<ul><li>As I discussed earlier, this is the second place for addrspace being used and you would need to update addrspace constructor call to provide thread id for creating a swap file</li><li>In any program, Exec() is called it reaches here and tries to setup addrspace for that program</li></ul></li><li>In SC_EXIT:<ul><li>Here you would need to make sure that the exiting program clear the used bits</li><li>you can consult the inverted page table that you would need to make to find the physical pages used by the current thread and clear those bits.</li></ul></li></ul></li><li><strong>Page fault exception (handling Demand Paging and Virtual Memory)</strong></li><li>Add new case PageFaultException under the same level as SyscallException and ReadOnlyException.</li><li>case PageFaultException<ul><li>increase pageFault stats ( You can create a separate page fault variable to keep track of it). There is already stats-&gt;numPageFaults defined which you can simply increase during page fault</li><li>get the address that caused page fault, badVAddr = machine-&gt;ReadRegister(BadVAddrReg);</li><li>calculate the virtual page, badVPage = badVAddr/PageSize</li><li>Find a physical page<ul><li>use bitMap-&gt;find()</li><li>if no free physical page is found depending on -V option</li></ul></li><li><strong>Task 5: Virtual Memory</strong><ul><li>If virtual memory is disabled, print not enough pages available and exit the program or end nachos. else find a page for replacement based on -V option<ul><li>--&gt; So obviously you need to have command-line arguments setup for -V option-<ul><li>V 1 --&gt; FIFO<ul><li>You can use list class to keep track of finding FIFO page to be replaced</li><li>We are just finding the physical page number that could be used by any thread to be replaced</li></ul></li><li>-V 2 --&gt; Random </li></ul></li></ul></li></ul><ul><li><ul><li><ul><li><ul><li>Just use a random function to find a physical page number between 0 to 31 to be replaced</li></ul></li></ul></li></ul></li></ul></li><li><ul><li>Once you find a physical page, use your IPT to identify which thread is currently using the page to be replaced</li><li>Check the page table of the replacing thread and see if the page is dirty of not <ul><li>If dirty, </li><li>Open the swapfile associated with that replacing thread </li><li>Write the content of that physical page to the swap file at its virtual page location (Here we are saving the contents to the disk so that when that thread runs it can load the updated content and continue its program)</li><li>update that thread's page table by setting the valid bit to false ( so that next time that thread runs it knows its content is no longer in memory and issues pageFaultException)</li><li>close the swap file</li><li>delete the pointer to swap file</li></ul></li><li>Open swapfile for the current thread</li></ul></li></ul><ul><li><ul><li><ul><li>copy the required content into the physical page that we just reserved</li><li>update the IPT[free_physical_page_number] and set it to the current thread</li><li>if replacement policy is fifo add the page number to the fifo list</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p> </p><ul><li><strong>Task 6: Output<br /></strong><ul><li>Again set up a command-line option -E which it is mentioned in command line arguments, enable extra output</li><li>Basically, set a variable and surround the extra prints that show details of everything going on</li><li>Go through the project description and make sure you have certain essential prints irrespective of -E option.</li><li>-E option is just to make sure that we have less and important prints on output.</li></ul></li></ul><p> </p><p> <strong>Inverted page Table</strong></p><p>It is simple and efficient as we just need to have an array size equal to the physical page number. </p><ul><li>Suppose our physical page number is 32, then just make an array of size 32 that holds the thread id or thread object.</li><li>Then, whenever you assign a physical page to a thread simple assign the value of that index to the thread id or thread object as IPT[physical_page_number_assigned] = thread_id or thread_object_pointer;</li><li>When you have to replace a page you can simply get the thread that is using the physical page.<ul><li>After that, you can check if the page is dirty or not.</li><li>If yes, then, first save the page in the swap file and then assign the page to the requested thread. </li></ul></li><li>When saving the content to the swap file you need to find the virtual page of the thread that was using the physical page<ul><li>You can do that by simply iterating through all the page_table and matching the virtual_page that was assigned to the physical page.</li><li>Another quick way will be to save the virtual_page of the thread too along with thread_id or thread_object_pointer to remove the search.</li></ul></li></ul><p> </p><p> </p><br /><p></p>
                        </div>                                     


<div class="text_to_html">Understanding ReadAt and WriteAt.<br /><br />
Suppose I want to copy content from a pointer executable to a buffer, we do like this<br /><br />
executable-&gt;ReadAt(buffer,size_to_copy, offset_to_read_from_executable);<br /><br />
The above statement will copy the content of the executable of the given size_to_copy into the buffer from the given offset.<br /><br /><br /><br />
Now, if I want to write the content from the buffer to executable, we do<br /><br />
executable-&gt;WriteAt(buffer, size_to_copy, offset_to_write_on_executable);<br /><br /><br /><br />
During page fault, you are copying a single page (bad virtual page) from executable or a swap file into the main memory (free physical page). So this is how we do it.<br /><br />
 executable-&gt;ReadAt(&amp;(machine-&gt;mainMemory[freePhysicalPage*PageSize]), PageSize, badVirtualPage*PageSize);<br /><br />
Here, ReadAt first argument should be the location where we want to write the page, which is given by <br /><br />
&amp;(machine-&gt;mainMemory[freePhysicalPage*PageSize]) . <br /><br />
Since we are writing a single page, our second argument of size should be PageSize .<br /><br />
The third argument should be the offset from where to copy and which is given by the badVirtualPage*PageSize<br /><br /><br /><br />
Now, if a page is dirty we need to write the content of the main memory into the swap file of the replacing thread. so we just do that using write at. <br /><br />
executable-&gt;WriteAt(&amp;(machine-&gt;mainMemory[replacingPhysicalPage*PageSize]), PageSize, badVirtualPage_of_replacing_thread*PageSize);</div>
                                    </div>
                                    
<div class="no-overflow w-100 content-alignment-container">
                                    <div id="post-content-126794" class="post-content-container">
                                        <div class="text_to_html">While Exiting following steps are essential,<br /><br />
Clear bitmap<br />
Just consult the IPT table and clear bits used by currentThread.<br />
Update FIFO list,<br />
Remove swapfile<br />
You can use fileSystem-&gt;Remove(swap_file_name_of_exiting_thread);</div>
                                    </div>
  
   <div class="no-overflow w-100 content-alignment-container">
                                    <div id="post-content-126795" class="post-content-container">
                                        <div class="text_to_html">Be careful when you have to replace page for virtual memory implementation.<br /><br />
when iterating through the pagetable of replacing thread, you need to first check if a pagetable is valid before you check if that pagetable physical page is associated with the physical page you are trying to replace. A pagetable content is valid only if itâ€™s valid bit is true.</div>
                                    </div>
